---
layout:     post
title:      日常笔记
subtitle:   萌新日常小笔记,随意更新！
date:       2019-11-03
author:     FormWeb
header-img: img/bg-note-web.jpeg
catalog: true
tags:
    - 日常笔记
---
### FreeBSD更新后 重新更新用户数据哭
```
cap_mkdb /etc/login.conf
pwd_mkdb -p /etc/master.passwd
```
### wget模拟浏览器下载
```
wget --user-agent="Mozilla/5.0" "http://stock.gtimg.cn/data/index.php?appn=detail&action=download&c=sh601818&d=20150508"  -O sh601818_20150508.txt

————————————————
版权声明：本文为CSDN博主「adream307」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/adream307/article/details/45623703
```
### 基于mpd5 VPN连接
```
cd /usr/ports/net/mpd5
make install clean
在 /etc/rc.conf 中启用 mpd5 添加如下行

mpd_enable="YES"
配置 mpd pptp VPN

复制默认的 mpd.conf 配置文件

cd /usr/local/etc/mpd5/
cp mpd.conf.sample mpd.conf
修改 mpd.conf 文件中的 startup: default: pptp_server: 三块，其它的不要理睬，放在里面不要删除，因为可以通过 default: 标签来调用需要执行的模块，所以不受影响。

以下是这三部分的代码，需要修改的地方见我的中文解释。

startup:
        # configure mpd users
        set user admin password ### 设置 mpd 的访问帐号及密码，通过 telnet 或 web 访问时需要此帐号
        #set user foo1 bar1
        # configure the console
        set console self 127.0.0.1 5005
        set console open
        # configure the web server
        set web self 0.0.0.0 5006
        set web open

#
# Default configuration is "dialup"

default:
        #load dialup
        load pptp_server ### 默认调用 pptp_server 模块

pptp_server:
#
# Mpd as a PPTP server compatible with Microsoft Dial-Up Networking clients.
#
# Suppose you have a private Office LAN numbered 192.168.1.0/24 and the
# machine running mpd is at 192.168.1.1, and also has an externally visible
# IP address of 1.2.3.4.
#
# We want to allow a client to connect to 1.2.3.4 from out on the Internet
# via PPTP.  We will assign that client the address 192.168.1.50 and proxy-ARP
# for that address, so the virtual PPP link will be numbered 192.168.1.1 local
# and 192.168.1.50 remote.  From the client machine's perspective, it will
# appear as if it is actually on the 192.168.1.0/24 network, even though in
# reality it is somewhere far away out on the Internet.
#
# Our DNS server is at 192.168.1.3 and our NBNS (WINS server) is at 192.168.1.4.
# If you don't have an NBNS server, leave that line out.
#

# Define dynamic IP address pool.
        set ippool add pool1 192.168.1.50 192.168.1.99

# Create clonable bundle template named B
        create bundle template B
        set iface enable proxy-arp
        set iface idle 1800
        set iface enable tcpmssfix
        set ipcp yes vjcomp
# Specify IP address pool for dynamic assigment.
        set ipcp ranges 192.168.1.1/32 ippool pool1
        set ipcp dns 8.8.8.8  ### 设置 dns
        #set ipcp nbns 192.168.1.4 ###如果你用不到 wins 的话，可以注释掉这块，
# The five lines below enable Microsoft Point-to-Point encryption
# (MPPE) using the ng_mppc(8) netgraph node type.
        set bundle enable compression
        set ccp yes mppc
        set mppc yes e40
        set mppc yes e128
        set mppc yes stateless
# Create clonable link template named L
        create link template L pptp
# Set bundle template to use
        set link action bundle B
# Multilink adds some overhead, but gives full 1500 MTU.
        set link enable multilink
        set link yes acfcomp protocomp
        set link no pap chap eap
        set link enable chap
        
# We can use use RADIUS authentication/accounting by including
# another config section with label 'radius'.
#       load radius
        set link keep-alive 10 60
# We reducing link mtu to avoid GRE packet fragmentation.
        set link mtu 1460
# Configure PPTP
        set pptp self 202.101.8.18 ###设置 pptp 的监听 ip 地址，也就是你的网卡的 IP 地址
# Allow to accept calls
        set link enable incoming
好了，就这么简单。

启动 mpd5

 /usr/local/etc/rc.d/mpd5 start
检查 mpd5 是否已经启动

netstat -a
可以看到类似于这样的输出信息

tcp4       0      0 vpn.server..pptp  *.*                    LISTEN
说明 pptp 已正常启动

添加 VPN 帐号

创建 /usr/local/etc/mpd5/mpd.secret 文件，输入用户名及密码，一行一个

如

vpnaccount1  password1
vpnaccount2  password2
riku         password3
然后就可以在 windows 下尝试登录 vpn 服务器了

启用包转发

以上配置好后，但只能访问内部网络，而不访问外网，所以要让服务器启用包转发。我用 ipfw 来提供此功能。

在 /etc/rc.conf 中加入以下行

gateway_enable="YES"
firewall_enable="YES"
firewall_type="OPEN"
firewall_logging_enable="YES"
natd_enable="YES"
natd_interface="em0" // em0 为网卡型号，你可以用 ifconfig 来检查你的网卡型号
编辑 ifpw 的规则文件 /etc/ipfw.rules

ipfw add allow all from any to any
ipfw add divert natd ip from any to any via em0
最后重新启动

当然如果你不想重启的话，也可以通过以下命令来启用包转发。

sysctl net.inet.ip.forwarding=1
/etc/rc.d/ipfw start
好了，配置完成。

高级：使用主机系统帐号登录

在 mpd.conf 中的 # load radius 后添加两行

        set auth disable internal  ### 禁止使用 mpd.secert 文件作为帐户认证
        set auth enable system-auth ### 添加系统认证方式
修改 /etc/login.conf ，把帐号加密方式改为 nth

        :passwd_format=nth:\
        #:passwd_format=md5:\
重建 login.conf 数据库

cap_mkdb /etc/login.conf
最后添加新帐户

adduser
用 mpd5 作为 pptp client 连接 VPN
这块也很简单，只要改一下默认配置中的几行，见下面代码中的中文注释。

另外，上面的default: 标签中要加入 load pptp_client 这行，以便重启 mpd 时加载 pptp client 模块。

pptp_client:
#
# PPTP client: only outgoing calls, auto reconnect,
# ipcp-negotiated address, one-sided authentication,
# default route points on ISP's end
#

        create bundle static B1
        set iface route default
        set ipcp ranges 0.0.0.0/0 0.0.0.0/0

        create link static L1 pptp
        set link action bundle B1
        set auth authname riku  ###VPN 帐号
        set auth password password  ###  VPN 密码
        set link max-redial 0
        set link mtu 1460
        set link keep-alive 20 75
        set pptp peer 208.1.2.3 ### VPN 服务器的 ip 地址
        set pptp disable windowing
        open
重启 mpd5

/usr/local/etc/rc.d/mpd5 restart
最后还需要重新设一下路由。

参考
mpd5.5 手册 http://mpd.sourceforge.net/doc5/mpd.html ipfw http://www.freebsd.org/doc/zh_CN/books/handbook/firewalls-ipfw.html

另外补充一下，需要在文件 /etc/rc.conf 中增加如下配置，以便开机时自动启动：

1
2
3
gateway_enable="YES"
pf_enable="YES"
mpd_enable="YES"
其中
gateway_enable="YES" 即 sysctl net.inet.ip.forwarding=1
pf_enable="YES" 对应 /etc/rc.d/pf restart
mpd_enable="YES" 对应 /usr/local/etc/rc.d/mpd5 start
```

### 更新后重新生成登录数据库
```
cap_mkdb /etc/login.conf
```
### tty常用快捷键
```
前提是 多用户，多任务

ctrl（右边） + L 清屏
ctrl + C 发送中断信号，结束某个操作或进程
alt + 左右箭头， 在多个tty 终端之间进行切换。新建tty 终端。
（tty 命令 查询你当前所处的终端号。 who 命令 查询当前登录的所有用户。）
pts
pts/0 pts/1 （本机图形界面打开连接， 远程 ssh ）

ctrl + u 从光标当前位置向前清除
ctrl + a 光标快速移动到行首

ctrl + e 光标快速移动到行尾

ctrl + s 挂起终端输入
ctrl + q 解锁输入

上下箭头，浏览命令的历史记录。history 命令，查询命令历史记录。
tab 键 （用好tab键，操作效率提升 70-80%）
智能查找
————————————————
版权声明：本文为CSDN博主「漂泊在云端的通配符」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
```
[原文链接](https://blog.csdn.net/qq_42777873/article/details/90055832)


### 比特币公链搭建
```
#环境 ubuntu 16.4
#硬盘500GB
#截止2018-12-31磁盘占用超过230GB

#客户端安装

 #下载页面
 #https://bitcoin.org/zh_CN/download

cd /opt/
wget https://bitcoin.org/bin/bitcoin-core-0.17.0.1/bitcoin-0.17.0.1-x86_64-linux-gnu.tar.gz

 #解压,软连接
tar zxf bitcoin-0.17.0.1-x86_64-linux-gnu.tar.gz
ln -fs /opt/bitcoin-0.17.0 /opt/bitcoin
ln -fs /opt/bitcoin-0.17.0/bin/bitcoind /usr/local/bin/bitcoind
ln -fs /opt/bitcoin-0.17.0/bin/bitcoin-cli /usr/local/bin/bitcoin-cli
#创建配置

mkdir -p /data/btc_data
mkdir ~/.bitcoin
vim ~/.bitcoin/bitcoin.conf
 # ~/.bitcoin/bitcoin.conf
datadir=/data/btc_data
dbcache=10240
txindex=1
rpcuser=btc
rpcpassword=btc2018
daemon=1
server=1
rest=1
rpcbind=0.0.0.0:8332
rpcallowip=0.0.0.0/0
deprecatedrpc=accounts
#后台启动

bitcoind -daemon
#关闭

bitcoin-cli stop
#查看区块链同步

bitcoin-cli getblockchaininfo
bitcoin-cli getmininginfo
#区块浏览器
# https://btc.com/

# rpc api访问

#curl访问rpc测试
curl -s -X POST --user btc:btc2018  \
  -H 'content-type: text/plain;' http://127.0.0.1:8332/ \
  --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getmininginfo", "params": [] }' 
#查询最新区块高度
curl -s -X POST --user btc:btc2018  \
  -H 'content-type: text/plain;' http://127.0.0.1:8332/ \
  --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getmininginfo", "params": [] }' \
  |awk -F '[:,]' '{print $3}'
#配置参数

rpcuser     远程访问的认证用户
rpcpassword 远程访问密码
daemon      在后台运行
rpcallowip  远程访问的ip或网段
txindex     所有交易进行索引；否则只保留钱包地址交易索引记录  
deprecatedrpc=accounts 启用账户"account"API ,V0.18版将被完全移除,新版"标签-label"API
#注意事项
#关闭后，再次启动时报错
#Cannot obtain a lock on wallet directory
#删除data目录.lock文件后，再次启动
#不配置datadir时,默认保存在 ~/.bitcoin/

#参考
https://blog.csdn.net/qq_38961394/article/details/82315629
https://blog.csdn.net/littlesmallless/article/details/83825784


```
[原文链接](https://www.cnblogs.com/elvi/p/10203927.html)


### 以太坊公链节点搭建

```
0x01 搭建节点需要什么配置

推荐配置:

CPU: 8 core
内存: 16G
硬盘: 500G SSD (固态硬盘)
网络: 5M+
最低配置:

CPU: 4 core
内存: 8G
硬盘: 500G 高速硬盘
网络: 2M
我自己搭节点用的是这里说的推荐配置，周一下午开始同步，周三早上来上班就已经同步好了。

0x02 节点是放国内还是国外

放国外安装过程会更顺利，国内云服务已经比较成熟了，但由于墙的原因，搭建过程稍微麻烦一点儿。
最近的这次安装，因为买国外服务器走公司财务比较麻烦，就买了阿里云的 VPS，因为公司其它系统用的都是 CentOS 6，这里也用了CentOS 6，其实网上关于 Ubuntu 和 CentOS 7的资料更多。

0x03 具体安装步骤

1. 安装 go 语言

安装 go 主要是为了去编译 go-ethereum 源码
平日里一般我都是用 gvm 去安装和管理不同版本的 go，但 gvm 在阿里云上默认是连不上所需要的 golang 下载服务器的。于是直接用下面一条命令搞定。

yum install golang
安装的版本不是最新的但也还是可以用的。

# go version
go version go1.11.5 linux/amd64
2. 安装 git

安装 git 主要是为了拉取 go-ethereum 源码
直接通过 yum 安装的版本比较老
我是通过下面的命令安装的：

yum install https://centos6.iuscommunity.org/ius-release.rpm
yum install epel-release
yum install git2u
得到下面的 git 版本

# git version
git version 2.16.4
ius 是专门用来提供 RPM 包的一个社区项目，具体可以查看 iuscommunity

3. 获取 go-ethereum 源码

可以通过下面的命令获取 go-ethereum 并切换到指定的 release branch

git clone https://github.com/ethereum/go-ethereum.git
cd go-ethereum/
git checkout release/1.9
接下来对源码进行编译

cd go-ethereum/
make all
编译之后会在 go-ethereum/build/bin 下生成各种二进制文件，其中包括接下来会用到的 geth

# ls
abigen  bootnode  clef  ethkey  evm  examples  faucet  geth  p2psim  puppeth  rlpdump  simulations  swarm  swarm-smoke  wnode
4. 添加 geth 到系统路径

打开 /etc/profile
将 export PATH=$PATH:/opt/ethereum/go-ethereum/build/bin 添加到文件最后
运行 source /etc/profile 将设置加载到当前 shell 环境
看到类似下面的结果说明就配置成功了
# geth version
Geth
Version: 1.9.5-stable
Git Commit: a1c09b93871dd3770adffb177086abda1b2ff3af
Git Commit Date: 20190920
Architecture: amd64
Protocol Versions: [63]
Network Id: 1
Go Version: go1.11.5
Operating System: linux
GOPATH=
GOROOT=/usr/lib/golang
5. 启动 geth 重要参数

直接在命令行运行 geth 不就行了么，当然可以，geth 会立马启动主网数据同步的准备工作。当还是建议关注一下下面的参数：

--datadir "xxxx" 指定数据目录，用来存放区块链数据，状态数据，keystore数据等。如果不加这个参数这些数据在不同的系统会放到不同的位置。这个目录占用空间是比较大的，我一般会指定一个目录，并保证这个目录所在分区有足够的磁盘空间。
--cache value 分配给内部缓存的内存MB数量，默认为 128，最后设置大一点儿，起码 1024吧，这个值设大一些可以提高数据同步效率。
--rpc                       启用HTTP-RPC服务器
--rpcaddr value             HTTP-RPC服务器接口地址(默认值:“localhost”)，默认只允许本地连接，设置为 0.0.0.0 可以接收任何地址发来的连接请求
--rpcport value             HTTP-RPC服务器监听端口(默认值:8545)，可以改为不同的端口
--ws                        启用WS-RPC服务器，几乎所有第三方节点都不启动这个服务，而要监听以太坊事件又必须启动这个服务
--wsaddr value              WS-RPC服务器监听接口地址(默认值:“localhost”)
--wsport value              WS-RPC服务器监听端口(默认值:8546)
最后启动 geth 的命令看起来是这样的：

geth --datadir data --cache 4096 --rpc --rpcport 6666 --rpcaddr 0.0.0.0  --ws --wsaddr 0.0.0.0 --wsport 6667 --wsorigins "*" 
这里把 rpcaddr 设为是的，最好指定特定 ip 地址或者通过反向代理或防火墙控制对 geth 节点的访问

6. 后台启动 geth

如果直接在 shell 终端直接启动 geth，终端关掉进程也就关掉了，可以通过下面的命令使 geth 在后台运行

nohup geth --datadir data --cache 4096 --rpc --rpcport 6666 --rpcaddr 0.0.0.0  --ws --wsaddr 0.0.0.0 --wsport 6667 --wsorigins "*" & > nohup.out
但如果直接在 shell 终端运行，可以用 CTRL + C 关闭进程，如何关闭运行在后台的 geth 进程呢，写了个简单的脚本如下：

#!/bin/sh
pid=`ps -ef|grep geth|grep -v grep|awk '{print $2}'`
echo $pid
kill -INT $pid
关于关闭 geth 进程，想了解更多可以查看这里。

0x04 监控同步状态

可以通过下面的命令 attach 到运行的节点，这里的 data 为上面启动 geth 时指定的 datadir 目录。

# geth attach data/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/SamewayProdNode2/v1.9.5-stable-a1c09b93/linux-amd64/go1.11.5
at block: 8637418 (Sat, 28 Sep 2019 20:52:34 CST)
 datadir: /opt/ethereum/prod/data
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
然后调用 eth.syncing, 如下面所示，可以看到当前的同步状态，我这边节点已经运行一段时间了，可以看到当前区块和最新区块高度是比较接近的。刚开始这两个数字差别是比较大的，在运行一天后这两个数字就开始比较接近，给人的感觉好像是快要同步完了，但实际上要再跑一天左右才能真正同步完成。

> eth.syncing
{
  currentBlock: 6143193,
  highestBlock: 6143296,
  knownStates: 91512910,
  pulledStates: 91498893,
  startingBlock: 0
}
在同步的过程中我们通过 eth.blockNumber 去查看当前区块号的话会显示为 0

> eth.blockNumber
0
这个时候看 geth 的输出的话，可以看到下面的日志

INFO [08-14|04:32:20] Imported new block headers
INFO [08-14|04:32:24] Imported new block receipts
INFO [08-14|04:32:33] Imported new state entries
可以通过 net.peerCount 来看自己的这个节点连了多少个其它节点进行数据同步。如果返回结果为0，就要自查一下了。

> net.peerCount
8
当看到 geth 日志里是下面的信息

# tail nohup.out 
INFO [08-16|14:20:15.307] Imported new chain segment               blocks=1  txs=117  mgas=7.979   elapsed=761.592ms mgasps=10.477  number=6156276 hash=56b327…03c068 cache=905.73mB
INFO [08-16|14:20:32.926] Imported new chain segment               blocks=1  txs=42   mgas=2.325   elapsed=143.505ms mgasps=16.204  number=6156277 hash=f577a7…1c6104 cache=905.59mB
INFO [08-16|14:20:35.940] Imported new chain segment               blocks=1  txs=121  mgas=7.992   elapsed=776.752ms mgasps=10.289  number=6156278 hash=c92744…2d1448 cache=905.67mB
调用 eth.blockNumber 得到的数字不再是 0 了，这个调用返回的是节点所同步到的最新区块号

> eth.blockNumber
6156294
这个时候调用 eth.syncing 会返回 false

> eth.syncing
false
恭喜你，区块数据已经同步完成了，该节点可以接收交易请求了。

0x05 常见问题

问题： 如果非正常关闭 geth 进程，比如机器强制重启的时候，如果这个时候以太坊正在执行数据库写操作，下次启动 geth 进程时就很容易碰到下面的错误信息：

Fatal: Error starting protocol stack: missing block number for head header hash
方案： 很不幸，目前还没有特别好的解决办法
需要通过下面的命令移除区块链数据并从新同步数据

# geth removedb --datadir data
问题： 数据同步经常落后主网若干区块，落后也不是很多，往往也就几十个区块，等段时间可以完成同步，可过段时间又落于主网了

方案： 确保节点监听端口 30303 已经在防火墙打开，此端口在防火墙放行后，可大大提高主网数据同步的稳定性

总结

本文讲解了以太坊主网节点搭建从准备到数据同步完成的全过程，希望能给有看到本文的人带来一些帮助。以后有相关经验积累也会同步更新到这篇文章中，大家在搭建节点的过程中有碰到什么问题，也可以给我留言或同我联系，同学习共进步

```
[原文链接](https://www.jianshu.com/p/719a34fe484d)

### FreeBSD安装配置nfs

```
rc.conf 增加
rpcbind_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"

/etc/exports 增加
/naspro  -alldirs  10.0.0.2 10.0.0.3 192.168.1.100


finder 访问 nfs：//192.168.1.100:/naspro

mount  -t nfs -o nolock, rsize=1024,wsize=1024,timeo=15 192.168.0.124:/home/admin/rootfs /mnt
```
```
在众多的文件系统中，FreeBSD的支持的是非常独特的，那就是网络文件系统(NFS)。NFS可以使一台或几台机器通过网络共享目录或文件。使用NFS，用户和程序能够访问远程系统上的文件就如同访问本地的一样。　 

NFS有以下几种特性：　 
本地工作站无须太多磁盘空间，因为常用的数据被存放在单一的机器上并且还会剩余一些空间可被网络上的其它人访问。　 

在网络上，每个用户不一定需要有唯一的home目录。一旦建立一个可以通过NFS使用的目录，那么它可以被网络上任何处访问。　 

像软盘和CD-ROM能够在网络上被其它机器访问，而不需要额外的硬件。　 

它如何工作　 
NFS由两个方面组成--客户端和服务器端。考虑到它们的联系，客户端需要服务器端所拥有的数据。服务器与客户共享数据。为了这个系统正常地工作，少数进程不得不在限制下运行。　 

服务器必须运行以下几个守护进程：　 
nfsd--NFS的守护进程，它响应客户的请求。　 
mountd--NFS　Mount守护进程，真正实现nfsd传递给它的客户请求。　 

客户端只需要运行一个守护进程：　 
nfsiod--NFS异步I/O守护进程，响应从NFS服务器来的请求。　 

设置NFS　 
非常幸运，在FreeBSD系统上设置它是非常容易的。只需通过极少的修改/etc/rc.conf文件，就可以在启动时运行这个进程了。　 

在NFS服务器上，请确定你有：　 
nfs_server_enable="YES"　 
nfs_server_flags="-u　-t　-n　4"　 
mountd_flags="-r"　 
每当NFS服务器启动时，mountd就自动运行了。-u和-t标志，告诉nfsd是否服务于UDP和TCP的客户端。-n　4标志，告诉nfsd运行自己的4个相同的拷贝。　 

在客户端，确定你有：　 
nfs_client_enable="YES"　 
nfs_client_flags="-n　4"　 
像nfsd,-n　4告诉nfsiod运行自己的4个拷贝。　 

最后一个设置是要求你建立一个叫作/etc/exports的文件。这个文件指定你的服务器使用何种文件系统，以及哪几个客户端将要共享。这个文件中的每一行指定一个需要被共享的文件系统。在文件可以使用的这些选择是比较烦的，但只需要涉及其中一部分。你可以查找man　page。　 

这儿有几个例子：　 
以下的几行输出/cdrom到三个"笨"机器上，它们有相同的域名，或者在你的/etc/hosts文件中登录过。-ro标志使得共享的文件系统只读，通过这个标志，远程系统将不可能在共享文件系统上作任何更改。　 
/cdrom　-ro　moe　larry　curly　 
下一行输出/home通过IP地址到三台主机。这是一个非常有用的设置，如果你有一个私有的网络，但没有DNS。-alldirs标志可以使指定的文件系统中的所有目录被输出。　 
/home　-alldirs　10.0.0.2　10.0.0.3　10.0.0.4　 
下一行输出/a到两台机器上，它们与NFS服务器在不同域上。-maproot=0标志允许在远程系统上的root用户，使用root权限向共享文件系统写入。除去-maproot=0标志，即使一些人有root权限访问远程系统，但它们不可以修改共享文件系统。　 
/a　-maproot=0　host.domain.com　box.example.com　 
为了使客户能够共享一个输出的文件系统，它必须有这个权限。确定你的客户列表在你的/etc/exports文件中。　 
现在你已经改动了设置，你可以reboot并且在启动时运行了。或者你也可以在命令行下输入：　 

在NFS服务器上：　 
#　nfsd　-u　-t　-n　4　 
#　mountd　-r　 
在NFS客户上：　 
#　nfsiod　-n　4　 
现在你已经准备真正地挂起一个远程文件系统。有两种方法。在这个例子中，服务器名字是server,而客户端是client。如果你只是临时挂起一个远程文件系统或希望测试一下你的设置，你可以在客户机的命令行下，以root的权限输入：　 
#　mount　server:/home　/mnt　 
这样将挂起在server上的/home到client的/mnt。如果一切都设置正确，那么你可以在/mnt下看见server上的文件.　 
如果你愿意每次启动时都挂起一人远程文件系统,那么你就需要修改你的/etc/fstab文件.例如:　 
server:/home　/mnt　nfs　rw　0　0　 
更多细节请参见fstab的man　page.　 


实际使用　 

NFS有许多非常"酷"的用途.我在我管理的网络上大量使用它.以下只是我使用它的一部分方法:.　 

在网络上,有好几台机器,但是只有一台机器有CD-ROM.为什么?因为我使用NFS使用所有的机器共享CD-ROM.而对于软驱其实也一样.　 

如此多的机器,而你的个人文件就存储地非常地分散了.我使用一台中央NFS服务器存储了所有的用户的home目录,并且与其它机器一起共享它们,所以无论从何处登录,我总是有相同的home目录.　 

当你准备在其中的一台机器上重新安装FreeBSD,使用NFS是一种方法.只要将光盘放入你的文件服务器,然后一切照旧.　 
我有一个公共目录:/usr/ports/distfiles,所有的机器都共享它.这样,当我将要在一台已经安装过某个port的机器上安装这个port时,我不需要重新再下载一遍所有的源文件.　 

问题汇总　 
某些ISA的以太网卡可能会引起一些问题,特别是在NFS上.这些困难在FreeBSD上并不特别明显,但系统可能会受影响.　 

这些问题几乎总是发生在以及联网的高性能工作站上,例如Sun公司的机器.NFS挂起将会工作非常好,一些操作也是成功的,但是突然server对client没有了响应,即使另外的系统请求继续被响应.这些问题通常在client系统上,无论client是FreeBSD或者是其它的工作站.许多系统上,一旦这个问题出现,系统将无法正常关闭.唯一的解决方法就是经常重置client,因为NFS的情况不能解决.　 
尽管这个"正确"的解决方法是对付运行FreeBSD的高性能工作站,但这也是一个简单的安全的方法.如果FreeBSD系统是server,client运行时要有参数-w=1024.如果FreeBSD是client,那么挂起NFS文件系统时,要有参数-r=1024.如果需要在client上自动挂起NFS,这些选择需要在fstab的第四个域中输入,或使用mount命令的-o参数手动挂起.　 

需要注意的是,在NFS　server和client在不同的网络上时,这个问题也会出现.如果是这个原因,请确定你的路由器有必须支持UDP信息.　 

下例中,fastws是高性能工作站的host名,freebox是一台有低效率网卡的FreeBSD系统.当然,/sharedfs将作为NFS文件系统,而在client上就是/project.在所用情况下,注意附加选项.　 

将freebox作为client:在/etc/fstab中输入　 
fastws:/sharedfs　/project　nfs　rw,-r=1024　0　0　 
如果是手工挂起:　 
#　mount　-t　nfs　-o　-r=1024　fastws:/sharedfs　/project　 
将freebox作为server,在fastws的/etc/fstab中输入:　 
freebox:/sharedfs　/project　nfs　rw,-w=1024　0　0　 
如果需要手工挂起:　 
#　mount　-t　nfs　-o　-w=1024　freebox:/sharedfs　/project　 
几乎任何16-bit以太网卡不需要以上的关于读写的限制.　 

对于细心的人,可能已经看出,何处出了这种错误,也就说明了此处为什么不可恢复正常的原因了.NFS是典型的每块8K的文件系统.(当然也可以优化成更小的).当最大的数据包在1500字节时,NFS的块被分成几个数据包,尽管它对于上层协议来说,还是一个独立的需要接收,确认并且组合的单元.高性能工作站能够从组成NFS单元的一个个紧接着的小包中还原这个包.在低效率的网卡中,后面的小包由于超时在与其在相同NFS单元中前面的小包到达目的地之前就会溢出,使用得整个单元不能被还原,并且不会发出确认信号.结果,工作站会超时,并且会重新再试一次,但是以8K一个单元,还是出现以上的错误,就这样永远休止.　 

使单元的大小小于数据包的尺寸限制,这样就可以确保信号会被接收,并且收到确认信号,从而避免以上局面.　 

当高性能服务器对一台配有高效的网卡的机器输入数据时,超时溢出仍会发生,但是这种超时溢出与以上所述的NFS的单元错误并不相同.当超时溢出发生时,受到影响的单元会被重传,而这次是它们被接收,确认,还原可能会成功.　 

```
[原文链接](http://www.studyems.com/network/d9ed673c86d67ad4.html)
```
freebsd 9开始，nfs采用v4协议，自然是版本高些，支持的特性多些，安全性更好些。我们今儿用的是最新的11.1-RELEASE

话说为啥要用FreeBSD？这linux不是也很好吗？ 答曰：为了稳定。
话说linux不稳定吗？答曰：年轻人，你对比了就知道了。传统UNIX应用，为了能在大负荷下连续开机三五年不出现异样，FreeBSD是明知的选择。

默认安装的时候，系统就已经带了nfs，所以就不需要安装了，直接上配置：

root@h-r720xd-1:/exports/backup # cat /etc/rc.conf
...
rpcbind_enable="YES"
mountd_enable="YES"
mountd_flags="-r"

nfs_server_enable="YES"
nfs_server_flags="-u -t -n 10"
nfs_reserved_port_only="YES"

nfsv4_server_enable="YES"
nfsuserd_enable="YES"
nfsuserd_flags="-domain host.cziic.cn"
...
备注一下：nfsuserd其实就是linux下的idmap，
nfsuserd_flags里面的 -domain host.cziic.cn 是nfsv4特有的配置，nfsv4是用user@domain的方式来完成用户认证的。

然后再来配置 /etc/exports 文件，这个文件里面是配置哪些目录可以被nfs client挂到。

root@h-r720xd-1:/exports/discuz/html # cat /etc/exports
V4: /  -network 10.23/16

/exports/discuz -maproot=root
V4: 这一行，是表示用nfsv4的协议来导出；-network 10.23/16是表示仅允许10.23.0.0/255.255.0.0的机器来访问。
/exports/discuz 是要导出的目录， -maproot=root是表示，所有root的操作，都会用本地root账号的权限来操作。这个有点类似 no_root_squash 的意思。

再看client端：

client端是台linux，起如下的服务：

nfsd
nfsiod
rpc.idmapd
rpcbind
rpc.mountd
rpc.statd
上述服务基本是通过如下命令来启动：

systemctl  start nfs
systemctl  start rpcbind
systemctl  start rpc-statd
systemctl  start nfs-idmapd
systemctl start nfs-mountd
对于nfsv4来说，idmapd还需要一个配置文件：/etc/idmapd.conf

$ cat /etc/idmapd.conf 
[General]
Domain = host.cziic.cn
...
[Translation]
Method = nsswitch
...
host.cziic.cn是在服务器的配置里定义的，要对应起来。

好了，现在要看看nfs server和nfs client两台机器上，用户是不是对应了，如果没有对应就相互建一下，不然如果涉及到用户的操作会失败的（诸如chown之类的操作）

开始 mount -t nfs 吧。。。

作者：贺鱼
链接：https://www.jianshu.com/p/c005bbde1cb6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 记一次手欠重装系统并恢复zfs数据
```
首先备份zfs缓存文件
cp -r /boot/zfs  ...
cp    /boot/zfsloader ...
cp    /boot/zfsboot ...
或者
zpool export your_pool_name


制作FreeBSD安装优盘 

使用软碟通写入优盘（写入模式必须选RAW）

安装完拷贝回原来位置
export import your_pool_name -c /boot/zfs/zfscache

sysrc zfs_enable="YES"

service zfs start

```

### 挂载优盘
<font size="2" color="gray">2019-11-07</font>

```
格式话优盘
newfs_msdos /dev/U盘分区。
```
```
格式化优盘或者硬盘
分区
删除ad0上所有分区
gpart destroy -F ad0
注: 没有数据情况才可以这样

创建gpt分区信息表
gpart create -s gpt ad0

创建分区
gpart add -b 34 -s 64k -t freebsd-boot ad0
gpart add -s 4096m -t freebsd-swap -l swap0 ad0
gpart add -s 608174080 -t freebsd-zfs -l root0 ad0

-b 开始扇区,可省略
-s 分区大小,单位可用扇区,K,M等
-t 分区类型, 还有freebsd-ufs
-l 给分区打标签

显示信息
gpart show ad0

删除分区
gpart delete -i 2
————————————————
版权声明：本文为CSDN博主「IChen.」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ichen820/article/details/100825410
```

### zfs操作记录

<font size="2" color="gray">2019-11-06</font>

```
1. 创建pool和ZFS文件系统：

. 创建文件系统，挂载在 /export/home 下
 
    # zfs create tank/home
    # zfs set mountpoint=/export/home tank/home
. 为多个用户创建起始目录
请注意：由于继承而自动挂载在 /export/home/{ahrens,bonwick,billm} 下
 
    # zfs create tank/home/ahrens
    # zfs create tank/home/bonwick
    # zfs create tank/home/billm
. 向池中添加更多空间
 
    # zpool add tank mirror c2t0d0 c3t0d0
. 创建名为 “tank” 的存储池 (type: “”,mirror,raidz,raidz2)
  
    # zpool create tank <type> c0t0d0 c1t0d0 c1t1d0

. 修改文件系统名称
  
    # zfs rename tank/home/ahrens tank/home/nahrens
. 删除文件系统
 
    # zfs destroy -Rf tank/fs

. 修改存储池的名称
    # zpool export tank
    # zpool import tank newpool

2. 设置属性

自动以 NFS 方式共享该文件系统
 
    # zfs set sharenfs=rw tank/home
 
对文件系统中所有数据启用压缩
 
    # zfs set compression=on tank
 
将用户 A的最大空间限制为 10g
 
    # zfs set quota=10g tank/home/usera
 
保证用户 B有 20g 的预留空间
 
    # zfs set reservation=20g tank/home/userb

可通过命令查询文件系统的所有属性
 
    # zfs get all tank/home
 
可通过命令查询存储池的所有属性
 
    # zpool get all tank
 
大多数属性可通过继承方式自动设置 
    # zfs inherit <property> tank/home/eschrock
 
3. ZFS snapshot
文件系统的只读副本
即时创建、数量不限,不占用额外空间 - 块仅在发生更改时才会被复制
可通过每个文件系统根目录下的 .zfs/snapshot 访问
使用户可在没有系统管理员介入的情况下恢复文件
对用户Ａ 的起始目录执行快照捕获
 
    # zfs snapshot tank/home/usera@tuesday
回滚到前一个快照
 
    # zfs rollback tank/home/usera@monday
查看星期三的 foo.c 版本
 
    $ cat /tank/home/usera/.zfs/snapshot/wednesday/foo.c
删除快照
 
    # zfs destroy -R tank/home/usera@monday3.ZFS Clone
快照的可写副本
    即时创建、数量不限
    存储大部分为共享数据的众多专用副本的理想方法
        软件安装
        工作区
        无盘客户机

创建 OpenSolaris 源代码的克隆
 
    # zfs clone tank/solaris@monday tank/ws/lori/fix

4. ZFS send/receive
基于快照点
    完整备份：任何快照
    增量备份：任何快照增量
        速度很快 - 开销与更改的数据成比例
 
非常高效，可执行远程复制
生成完整备份
 
    # zfs send tank/fs@A >/backup/A    
生成增量备份
 
    # zfs send -i tank/fs@A tank/fs@B >/backup/B-A
远程复制：每分钟发送一次增量
 
    # zfs send -i tank/fs@11:31 tank/fs@11:32 |
      ssh host zfs receive -d /tank/fs

5. ZFS 数据迁移

独立于主机的磁盘格式
    将服务器从 x86 更改为 SPARC，也能运行
    自适应字节存储顺序 (Adaptive endianness)：在两个平台上都无需额外成本
        写入总是使用本地字节存储顺序 (native endianness)，在块指针中设置位
        仅当主机字节存储顺序 (endianness) != 块字节存储顺序时，才会针对读取进行字节交换
 
ZFS 负责所有处理
    无需考虑设备路径、配置文件、/etc/vfstab 等等
    ZFS 会在必要时进行共享/取消共享、挂载/取消挂载等等

从旧服务器上导出池
 
    old# zpool export tank
 
物理移动磁盘并将池导入到新服务器中
 
    new# zpool import tank

6. 设备管理
添加/替换新设备 (type: “”,mirror,raidz,raidz2)
 
    # zpool add tank <type> c0t2d0 c0t3d0 c0t4d0
    # zpool replace tank c0t1d0 c0t2d0
 
添加/移除镜像设备
 
    # zpool attach tank c0t1d0 c0t2d0
    # zpool detach tank c0t2d0
 
将设备停止或手工启动 
  # zpool offline tank c0t2d0
    # zpool online tank c0t2d0
 
查看存储池当前状态和 I/O 状况
 
    # zpool status -v tank
    # zpool iostat tank 1
添加热备设备
 
    # zpool add tank spare c0t2d0
 
指定热备启动/停止热备
 
    # zpool replace tank c0t1d0 c0t2d0
    # zpool detach tank c0t2d0
 
将热备设备删除
  # zpool remove tank c0t2d0
 
添加/删除独立的日志设备（性能改善）
 
    # zpool add tank log c0t3d0
    # zpool remove tank c0t3d0

7. ZFS 权限管理
可以将zfs(1M) 的管理权限分派给普通用户
    'zfs allow'
    'zfs unallow'
将权限授予一个普通用户
    # zfs allow marks create,snapshot tank/marks
将指定权限回收
    # zfs unallow marks create,snapshot tank/marks
查看文件系统当前的权限
    # zfs allow tank/marks

8. 其它命令
显示存储池所有操作历史记录
  
    # zpool history tank
升级存储池到指定 SPA 版本
 
    # zpool upgrade -V <version> tank
升级文件系统到指定 ZPL 版本
    # zfs upgrade -V <version> tank/fs
手工挂载/卸载文件系统
    # zfs mount -a
    # zfs unmount tank/fs
    # zfs unmount -a

以上内容摘自一位工程师presentation，录于此，以备速查。

du -hd1
```
```
zpool attach zfs  ada1 ada2

zpool detach zfs  ada1 ada4

zpool  set  mountpoint=/diskz diskz

zfs mount -a





zfs set compression=on diskz

zfs set compression=lz4 diskz

zfs get all diskz


zfs set exec=off diskz

zfs set setuid=off diskz

zpool create -f  testzpool raidz ada1 ada2 ada3 ada4

ls -aIR | wc -l

zfs iostat diskz 1

zfs get mountpoint naspro


1. zpool create naspro raidz ada1 ada2 ada3 ada4

2.zfs set compression=lz4 naspro

3.zfs set setuid=off naspro

4.zfs set exec=off naspro

5.mkdir -p /naspro

6.zpool  set  mountpoint=/naspro naspro



7.mkdir -p /usr/local/etc/pkg/repos 

8.cd /usr/local/etc/pkg/repos

9.vi 0.chinafreebsd.conf

10.

chinafreebsd: {
  url: "pkg+http://pkg.chinafreebsd.cn/${ABI}/quarterly",
  mirror_type: "srv",
  signature_type: "none",
  fingerprints: "/usr/share/keys/pkg",
  enabled: yes
}


11.

echo "FreeBSD: { enabled: no }" > /usr/local/etc/pkg/repos/FreeBSD.conf


12.

pkg update -f 或者 pkg update -r chinafreebsd



13.
pkg install bash

14.
chsh -s /usr/local/bin/bash
chsh -s /bin/csh

/etc/profile

export LC_ALL="zh_CN.UTF8

################
##export LC_ALL=zh_CN-UTF-8

##:set fenc    // 在vim命令行下
  fileencoding=utf-8    // vim命令行下的输出
:set tenc    // 同上
  termencoding=utf-8
##############




15.
pkg install vim-console

16.
ntpdate -u time.windows.com
ifocnifg em0 down
ifconfig em0 up
dhclient em0

17.
pkg install go

18.
ceport GOPATH=/usr/root/go


19.
pkg install git


20.
/etc/ssh/sshd_config


21.
service sshd start

22.
pw useradd naspro -g wheel -s wheel 或者 pw useradd naspro -> pw usermode naspro -g wheel -s bin/bash

23.
更改文件用户组 chgrp ？？ ？？


24.
pkg install tmux


25.
vim /etc/hosts

 # GitHub Start 
192.30.253.112 github.com 
192.30.253.119 gist.github.com 
151.101.100.133 assets-cdn.github.com 
151.101.100.133 raw.githubusercontent.com 
151.101.100.133 gist.githubusercontent.com 
151.101.100.133 cloud.githubusercontent.com 
151.101.100.133 camo.githubusercontent.com 
151.101.100.133 avatars0.githubusercontent.com 
151.101.100.133 avatars1.githubusercontent.com 
151.101.100.133 avatars2.githubusercontent.com 
151.101.100.133 avatars3.githubusercontent.com 
151.101.100.133 avatars4.githubusercontent.com 
151.101.100.133 avatars5.githubusercontent.com 
151.101.100.133 avatars6.githubusercontent.com 
151.101.100.133 avatars7.githubusercontent.com 
151.101.100.133 avatars8.githubusercontent.com 
# GitHub End


26.
pw useradd mozii -s /usr/local/bin/bash -g wheel -d /naspro/mozii

passwd mozii


27.
pkg install samba48

sysrc samba_server_enable=YES

vim /etc/rc.conf

nmbd_enable="YES"
winbindd_enable="YES"
samba_enable="NO"
samba_server_enable="YES"

29.

find . -name '.*' -type f -print -exec rm -rf {} \;


find  .  -name  '*.*'  -type  f  -print  -exec  rm  -rf  {} \;

(1) "."    表示从当前目录开始递归查找

(2) “ -name '*.*' "根据名称来查找，要查找所有以.*结尾的文件夹或者文件

(3) " -type f "查找的类型为文件

(4) "-print" 输出查找的文件目录名

(5) exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。

     exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号

find . -name '.DS_Store' -type f -print -exec rm -rf {} \;

find . -name '._.DS_Store' -type f -print -exec rm -rf {} \;


####权限使用系统用户权限控制
smbpasswd -a naspro 并输入密码 增加用户

*/usr/local/etc/smb4.conf*

[global]
    workgroup = WORKGROUP
    server string = mozii BeiJing Samba Server  Version %v
    
    log level = 1
    log file = /var/log/samba/%m
    max log size = 50

    security = user
    passdb backend = tdbsam

    load printers = no
    cups options = raw

    guest account = nobody

    config file = /usr/local/etc/%U.smb4.conf

[NasPro]
    path = /naspro    
    browseable = yes
    vaild users = root
    admin users = root
    public = no
    readonley = no

    writeable=yes
    create mask=0664
    directory mask=0775



*/usr/lcoal/etc/mozii.smb4.conf*

[moziiShareServer]

comment = This is moziiBeiJing Sharing Server !
path = /naspro/mozii
write list = naspro

*/usr/lcoal/etc/naspro.smb4.conf*

[moziiShareServer]

comment = This is moziiBeiJing Sharing Server !
path = /naspro/mozii
readonly = yes
read list = mozii,@mozii

chown -R naspro mozii

pw usermod mozii -g mozii

chmod -R 755 mozii



30.
pkg install aria2

aria2c --enable-rpc --rpc-listen-all

pkg install node

node node-server.js

git clone https://github.com/ziahamza/webui-aria2.git

cp -R ./src /usr/local/www/webui

cd /usr/local/www/webui

chmod -R 755 webui


浏览器访问 IP：8888



31.
pkg install nginx

///aria2c http://h264.code-shop.com/download/nginx_mod_h264_streaming-2.2.7.tar.gz


///tar -zxvf nginx_mod_h264_streaming-2.2.7.tar.gz



32.tmux 使用

 

会话管理　

常用命令

tmux new　　创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令）

tmux new -s mysession　　创建名为mysession的会话

tmux ls　　显示会话列表

tmux a　　连接上一个会话

tmux a -t mysession　　连接指定会话

tmux rename -t s1 s2　　重命名会话s1为s2

tmux kill-session　　关闭上次打开的会话

tmux kill-session -t s1　　关闭会话s1

tmux kill-session -a -t s1　　关闭除s1外的所有会话

tmux kill-server　　关闭所有会话

常用快捷键

prefix s　　列出会话，可进行切换

prefix $　　重命名会话

prefix d　　分离当前会话

prefix D　　分离指定会话

　　

窗口管理

prefix c　　创建一个新窗口

prefix ,　　重命名当前窗口

prefix w　　列出所有窗口，可进行切换

prefix n　　进入下一个窗口

prefix p　　进入上一个窗口

prefix l　　进入之前操作的窗口

prefix 0~9　　选择编号0~9对应的窗口

prefix .　　修改当前窗口索引编号

prefix '　　切换至指定编号（可大于9）的窗口

prefix f　　根据显示的内容搜索窗格

prefix &　　关闭当前窗口

　

窗格管理

prefix %　　水平方向创建窗格

prefix "　　垂直方向创建窗格

prefix Up|Down|Left|Right　　根据箭头方向切换窗格

prefix q　　显示窗格编号

prefix o　　顺时针切换窗格

prefix }　　与下一个窗格交换位置

prefix {　　与上一个窗格交换位置

prefix x　　关闭当前窗格

prefix space(空格键)　　重新排列当前窗口下的所有窗格

prefix !　　将当前窗格置于新窗口

prefix Ctrl+o　　逆时针旋转当前窗口的窗格

prefix t　　在当前窗格显示时间

prefix z　　放大当前窗格(再次按下将还原)

prefix i　　显示当前窗格信息

 

　　

其他命令

tmux list-key　　列出所有绑定的键，等同于prefix ?

tmux list-command　　列出所有命令

　　

以上为tmux的常见操作，基本可以满足大部分的工作需求，至于更高端的操作待日后再整理。


33.
pkg install gogs

======================================================================
You installed gogs: Go Git Service.

It is recommended to run gogs as a service:
# service gogs start

To enable the service at startup you should execute the command:
sysrc gogs_enable="YES"

You can also run gogs manually with a command:
# gogs

Connect to gogs on the default port 3000:
http://localhost:3000

Configuration file is /usr/local/etc/gogs/conf/app.ini.
You can only edit it when gogs isn't running.

Gogs needs an SSH daemon, so make sure sure you execute:
sysrc sshd_enable="YES"
and sshd is configured to listen on the same port that is configured
in gogs.
======================================================================

pkg install postgresql96-server

---
postgres:\
        :lang=en_US.UTF-8:\
        :setenv=LC_COLLATE=C:\
        :tc=default:
---
and run `cap_mkdb /etc/login.conf'.
Then add 'postgresql_class="postgres"' to /etc/rc.conf.

======================================================================

To initialize the database, run

  /usr/local/etc/rc.d/postgresql initdb

You can then start PostgreSQL by running:

  /usr/local/etc/rc.d/postgresql start

For postmaster settings, see ~pgsql/data/postgresql.conf

NB. FreeBSD's PostgreSQL port logs to syslog by default
    See ~pgsql/data/postgresql.conf for more info

NB. If you're not using a checksumming filesystem like ZFS, you might
    wish to enable data checksumming. It can only be enabled during
    the initdb phase, by adding the "--data-checksums" flag to
    the postgres_initdb_flags rcvar.  Check the initdb(1) manpage
    for more info and make sure you understand the performance
    implications.

======================================================================

To run PostgreSQL at startup, add
'postgresql_enable="YES"' to /etc/rc.conf


 /usr/local/etc/rc.d/postgresql initdb

psql -U postgres

cteate user goga;

create database gogs owner gogs;

grant all privileges on database gogsdb to gogs;

alter user gogs with password 'your-password';


34.
dbus_enable="YES" hald_enable="YES" kdm5_enable="YES"
```
### KDE安装的一些命令
<font size="2" color="gray">2019-11-05</font>


```
pkg update

freebsd-update fetch

freebsd-update install

pkg install nano  ????


pkg install xorg sddm(多用户登录) kde5 twm kdevelop

/etc/rc.conf

dbus_enable="YES"
sddm_enable="YES"
/etc/sysctl.conf

星号中间命令作用存疑
************************************
**net.local.stream.recvspace=65536**
**net.local.stream.sendspace=65536**
************************************

whereis Xorg
找到其绝对路径，然后执行绝对路径，还有X是大写，非小写：
Xorg -configure
Xorg -config xorg.conf.new
cp xorg.conf.new /etc/X11/xorg.conf

pw usermod -n mozii -g wheel  改进wheel组
```

### PostgreSQL命令  
<font size="2" color="gray">2019-11-05</font>



```
Psql -U pgsql -d postgres

db_connect user:password@localhost/dbname

FREEBSD安装POSTGRESQL笔记
 更新时间：2015年02月18日 15:32:17   投稿：junjie     我要评论

这篇文章主要介绍了FREEBSD安装POSTGRESQL笔记,本文着重讲解安装中遇到到的一些问题和解决方法,需要的朋友可以参考下
折腾了好长时间，重新初始化好多次。

安装的时候，命令：pkg search postgresql.额 好多包，选择最新的9.4安装server，会一起安装client。安装完会有很多文字提示，这个很有用。安装完会新建一个用户pgsql，家目录为/usr/local/pgsql.

第一步

要先切换到pgsql用户下，su root， su pgsql。然后在pgsql home目录创建data文件夹。root用户下好像是不允许的
初始化，initdb -D /usr/local/pgsql/data/ ，会生成很多文件。初始化数据库存储区，会自动创建一个 postgres的数据库，放乱七八糟的设置和第三方插件的数据。还会有一个模板 template1。这里还不是很清楚，以后创建数据库就会用这个模板创建。这里要说的是数据库编码的问题，这里悲剧的初始化了好多次。
默认执行上边的命令后，提示文字会跟你说（当时没看。。）默认数据库编码为“sql_ascii”，默认文本搜索设置为 english。。我靠执行的时候就瞅着屏幕发呆了，就等执行完。。。重新初始化的方法，我也是从提示中看到的，直接initdb会提示你 要清空原来文件夹或者新建。直接rm -rf *.initdb �Chelp
可以看到字符编码的设定用�Cencoding ,initdb �Cencoding=UTF8 -D /usr/local/pgsql/data/

启动postgresql，启动脚本/usr/local/etc/rc.d/postgresql。开始要添加到/etc/rc.conf文件，这个也是有提示的。
status not running,start成功

创建数据库，createdb �Cencoding=UTF-8 bt，使用客户端连接，qsql bt,
进去后 show server_encoding;查看server编码，utf8
\encoding 查看客户端编码。客户端还是SQL_ASCII,可以使用/encoding utf8改变客户端编码。
也可以直接使用\l查看。

ok了 基本没别的问题了




最近一直在学习Postgresql，下面是自己整理的Postgresql的常用命令

连接数据库, 默认的用户和数据库是postgres
psql -U user -d dbname

切换数据库,相当于mysql的use dbname
\c dbname
列举数据库，相当于mysql的show databases
\l
列举表，相当于mysql的show tables
\dt
查看表结构，相当于desc tblname,show columns from tbname
\d tblname

\di 查看索引 

创建数据库： 
create database [数据库名]; 
删除数据库： 
drop database [数据库名];  
*重命名一个表： 
alter table [表名A] rename to [表名B]; 
*删除一个表： 
drop table [表名]; 

*在已有的表里添加字段： 
alter table [表名] add column [字段名] [类型]; 
*删除表中的字段： 
alter table [表名] drop column [字段名]; 
*重命名一个字段：  
alter table [表名] rename column [字段名A] to [字段名B]; 
*给一个字段设置缺省值：  
alter table [表名] alter column [字段名] set default [新的默认值];
*去除缺省值：  
alter table [表名] alter column [字段名] drop default; 
在表中插入数据： 
insert into 表名 ([字段名m],[字段名n],......) values ([列m的值],[列n的值],......); 
修改表中的某行某列的数据： 
update [表名] set [目标字段名]=[目标值] where [该行特征]; 
删除表中某行数据： 
delete from [表名] where [该行特征]; 
delete from [表名];--删空整个表 
创建表： 
create table ([字段名1] [类型1] ;,[字段名2] [类型2],......<,primary key (字段名m,字段名n,...)>;); 

\copyright     显示 PostgreSQL 的使用和发行条款
\encoding [字元编码名称]
                 显示或设定用户端字元编码
\h [名称]      SQL 命令语法上的说明，用 * 显示全部命令
\prompt [文本] 名称
                 提示用户设定内部变数
\password [USERNAME]
                 securely change the password for a user
\q             退出 psql



可以使用pg_dump和pg_dumpall来完成。比如备份sales数据库： 
pg_dump drupal>/opt/Postgresql/backup/1.bak 



附带一些指定给postgresql用户的常用命令:

默认用户
postgres安装完成后，会自动在操作系统和postgres数据库中分别创建一个名为postgres的用户以及一个同样名为postgres的数据库。

登录
方式1:指定参数登录
psql -U username -d database_name -h host -W

参数含义: -U指定用户 -d要连接的数据库 -h要连接的主机 -W提示输入密码。

方式2:切换到postgres同名用户后登录
su username
psql

当不指定参数时psql使用操作系统当前用户的用户名作为postgres的登录用户名和要连接的数据库名。所以在PostgreSQL安装完成后可以通过以上方式登录。

创建用户
方式1:在系统命令行中使用createuser命令中创建
createuser username 

方式2:在PostgresSQL命令行中使用CREATE ROLE指令创建
CREATE ROLE rolename;

方式3:在PostgresSQL命令行中使用CREATE USER指令创建
CREATE USER username;

CREATE USER和CREATE ROLE的区别在于，CREATE USER指令创建的用户默认是有登录权限的，而CREATE ROLE没有。

\du 指令显示用户和用户的用户属性 
创建用户时设定用户属性
基本语法格式
CREATE ROLE role_name WITH optional_permissions;

示例:在创建用户时设定登录权限。
CREATE ROLE username WITH LOGIN;

可以通过\h CREATE ROLE指令查看全部可设置的管理权限
修改用户属性
修改权限的命令格式
ALTER ROLE username WITH attribute_options;

例如:可通过以下方式禁止用户登录
ALTER ROLE username WITH NOLOGIN;

设置访问权限
语法格式如下:
GRANT permission_type ON table_name TO role_name;

实例:
GRANT UPDATE ON demo TO demo_role; --赋予demo_role demo表的update权限
GRANT SELECT ON ALL TABLES IN SCHEMA PUBLIC to demo_role; --赋予demo_role所有表的SELECT权限

特殊符号:ALL代表所访问权限，PUBLIC代表所有用户
GRANT ALL ON demo TO demo_role; --赋给用户所有权限
GRANT SELECT ON demo TO PUBLIC; --将SELECT权限赋给所有用户

\z或\dp指令显示用户访问权限。
\h GRANT显示所有可设置的访问权限
撤销用户访问权限
语法格式如下:
REVOKE permission_type ON table_name FROM user_name;

其中permission_type和table_name含义与GRANT指令中相同。

用户组
在postgres中用户实际上是role，同时组也是role。 包含其他role的role就是组。

创建组示例:
CREATE ROLE temporary_users;
GRANT temporary_users TO demo_role;
GRANT temporary_users TO test_user;

切换ROLE
SET ROLE role_name; --切换到role_name用户
RESET ROLE; --切换回最初的role

INHERIT权限：该属性使组成员拥有组的所有权限
ALTER ROLE test_user INHERIT;

删除用户和组
删除用户和组很简单:

DROP ROLE role_name;
DROP ROLE IF EXISTS role_name;

删除组role只会删除组的role本身，组的成员并不会被删除


--今天在使用postgres_fdw做远端数据库转储时，发现本地所使用的字符集与远端是不同的，造成插入数据错误
postgres=# insert into t select * from for_t; ? ?
ERROR: ?character with byte sequence 0xe7 0xa6 0xb4 in encoding "UTF8" has no equivalent in encoding "EUC_CN"
CONTEXT: ?Remote SQL command: SELECT ?pnr FROM rudy.t


--本地的编码
postgres=# select name,setting,context from pg_settings ?where name like '%encoding%'; ? ??
? ? ? name ? ? ? | setting | context ?
-----------------+---------+----------
?client_encoding | UTF8 ? ?| user
?server_encoding | EUC_CN ?| internal
?
?--远端的数据库编码
?dev=# select name,setting,context from pg_settings ?where name like '%encoding%'; ? ??
? ? ? name ? ? ? | setting | context ?
-----------------+---------+----------
?client_encoding | UTF8 ? ?| user
?server_encoding | UTF8 ? ?| internal
?
?
?--可以选择导出数据，使用inserts方式，再执行导入
?pg_dump -d dev -t rudy.t --data-only --inserts -f /tmp/t.sql
?psql -l -f /tmp/t.sql
?
?--注意使用这种方式导入时比较慢
?--如果其中某一行命令出错，那么将仅有该行数据丢失，而不是整个表的数据丢失，即不能做到事务安全
?--由于编码的原因会造成一部分数据不能导入成功
?ERROR: ?character with byte sequence 0xe7 0xa6 0xb4 in encoding "UTF8" has no equivalent in encoding "EUC_CN"
?
?
?
?--也可以重新初始化一个新的数据库集群
--备份整个数据库集群
?pg_dumpall -f /tmp/pg_dump.sql
? mv data/ data_bak
? initdb -E UTF8 --local=C
? --覆盖新生成的配置文件
? cp ../data_bak/postgresql.conf .
? cp ../data_bak/pg_hba.conf .?
?--导入之前导出的文件则可
? psql -f /tmp/pg_dump.sql
 

命令行方式登录PostgreSQL、创建用户和数据库并赋权
2017年09月12日 09:10:44 zhangzeyuaaa 阅读数：25382更多
个人分类： 数据库
目录：

　　一、在默认配置条件下，本机访问PostgreSQL

　　二、创建新用户来访问PostgreSQL

　　三、最简单的做法

　　四、开启远程访问

 

一、在默认配置条件下，本机访问PostgreSQL

切换到Linux用户postgres，然后执行psql：

$ su - postgres

Last login: Wed Mar 1 13:16:48 CST 2017 on pts/1
-bash-4.2$ psql

psql (9.2.18)
Type "help" for help.

postgres=#

此时就在数据库postgres中了。

使用 psql -d [databasename] 可登录其他数据库。

注意：执行psql命令时，必须确认已配置postgresql的环境变量。


二、创建新用户来访问PostgreSQL

1、如上所述，先切换到Linux用户postgres，并执行psql：

$ su - postgres

-bash-4.2$ psql

postgres=#

现在位于数据库提示符下。

2、创建数据库新用户，如 dbuser：

postgres=# C
D '*****';
注意：

语句要以分号结尾。
密码要用单引号括起来。
3、创建用户数据库，如exampledb：

postgres=# CREATE DATABASE exampledb OWNER dbuser;
4、将exampledb数据库的所有权限都赋予dbuser：

postgres=# GRANT ALL PRIVILEGES ON DATABASE exampledb TO dbuser;
5、使用命令 \q 退出psql：

postgres=# \q
6、创建Linux普通用户，与刚才新建的数据库用户同名，如 dbuser：

$ sudo adduser dbuser

$ sudo passwd dbuser

7、以dbuser的身份连接数据库exampledb：

$ su - dbuser

Password: 
Last login: Wed Mar 1 11:52:07 CST 2017 on pts/

[dbuser@master ~]$ psql -d exampledb 

三、最简单的做法

以你的普通Linux用户名，在数据库中创建同名的用户和数据库，如xxf，然后就可以本机直接连接到数据库xxf了。

~> su - postgres
Password: 
Last login: Wed Mar 1 13:19:02 CST 2017 on pts/1
-bash-4.2$ psql
psql (9.2.18)
Type "help" for help.

postgres=# create user xxf with password '******';
CREATE ROLE
postgres=# create database xxf owner xxf;
CREATE DATABASE
postgres=# grant all privileges on database xxf to xxf;
GRANT
postgres=# \q
-bash-4.2$ exit
logout
~> psql
psql (9.2.18)
Type "help" for help.

xxf=>

至此，就在数据库xxf中了。 

 
四、开启远程访问

1、编辑配置文件

文件：postgresql.conf

位置：/var/lib/pgsql/data/postgresql.conf

添加/修改：在所有IP地址上监听，从而允许远程连接到数据库服务器：

listening_address: '*'

 

文件：pg_hba.conf

位置：/var/lib/pgsql/data/pg_hba.conf

添加/修改：允许任意用户从任意机器上以密码方式访问数据库，把下行添加为第一条规则：

host    all             all             0.0.0.0/0               md5

 

2、重启数据库服务：

$ sudo systemctl restart postgresql

 

3、此后即可从其它机器上登录，例如用Navicat for PostgreSQL：

主机名或IP： 172.*.*.*

端口：          5432

初始数据库： xxf

用户：          xxf

密码：          ******  (数据库用户xxf的密码，不是Linux用户xxf的密码)
```
### Tmux快捷键&速查表
<font size="2" color="gray">2019-11-05</font>


```
启动新会话：

tmux [new -s 会话名 -n 窗口名]

恢复会话：

tmux at [-t 会话名]

列出所有会话：

tmux ls

关闭会话：

tmux kill-session -t 会话名

关闭所有会话：

tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, 
length($1)-1)}' | xargs kill

在 Tmux 中，按下 Tmux 前缀 ctrl+b，然后：

会话

:new<回车>  启动新会话
s           列出所有会话
$           重命名当前会话


窗口 (标签页)

c  创建新窗口
w  列出所有窗口
n  后一个窗口
p  前一个窗口
f  查找窗口
,  重命名当前窗口
&  关闭当前窗口
 
调整窗口排序

swap-window -s 3 -t 1  交换 3 号和 1 号窗口
swap-window -t 1       交换当前和 1 号窗口
move-window -t 1       移动当前窗口到 1 号
1
2
3
窗格（分割窗口）

%  垂直分割
"  水平分割
o  交换窗格
x  关闭窗格
⍽  左边这个符号代表空格键 - 切换布局
q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格
{ 与上一个窗格交换位置
} 与下一个窗格交换位置
z 切换窗格最大化/最小化


同步窗格

这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：

:setw synchronize-panes
1
你可以指定开或关，否则重复执行命令会在两者间切换。 
这个选项值针对某个窗口有效，不会影响别的会话和窗口。 
完事儿之后再次执行命令来关闭。帮助

调整窗格尺寸

如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：

PREFIX : resize-pane -D          当前窗格向下扩大 1 格
PREFIX : resize-pane -U          当前窗格向上扩大 1 格
PREFIX : resize-pane -L          当前窗格向左扩大 1 格
PREFIX : resize-pane -R          当前窗格向右扩大 1 格
PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格
PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格

文本复制模式：

按下前缀 [进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：

setw -g mode-keys vi
1
启用这条配置后，就可以使用 h、j、k、l 来移动光标了。

想要退出文本复制模式的话，按下回车键就可以了。一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。

例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。

vi             emacs        功能
^              M-m          反缩进
Escape         C-g          清除选定内容
Enter          M-w          复制选定内容
j              Down         光标下移
h              Left         光标左移
l              Right        光标右移
L                           光标移到尾行
M              M-r          光标移到中间行
H              M-R          光标移到首行
k              Up           光标上移
d              C-u          删除整行
D              C-k          删除到行末
$              C-e          移到行尾
:              g            前往指定行
C-d            M-Down       向下滚动半屏
C-u            M-Up         向上滚动半屏
C-f            Page down    下一页
w              M-f          下一个词
p              C-y          粘贴
C-b            Page up      上一页
b              M-b          上一个词
q              Escape       退出
C-Down or J    C-Down       向下翻
C-Up or K      C-Up         向下翻
n              n            继续搜索
?              C-r          向前搜索
/              C-s          向后搜索
0              C-a          移到行首
Space          C-Space      开始选中
               C-t          字符调序


杂项：

d  退出 tmux（tmux 仍在后台运行）
t  窗口中央显示一个数字时钟
?  列出所有快捷键
:  命令提示符

配置选项：

# 鼠标支持 - 设置为 on 来启用鼠标
* setw -g mode-mouse off
* set -g mouse-select-pane off
* set -g mouse-resize-pane off
* set -g mouse-select-window off

# 设置默认终端模式为 256color
set -g default-terminal "screen-256color"

# 启用活动警告
setw -g monitor-activity on
set -g visual-activity on

# 居中窗口列表
set -g status-justify centre

# 最大化/恢复窗格
unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmp
unbind Down
bind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp

配置文件（~/.tmux.conf）：

# 基础设置
set -g default-terminal "screen-256color"
set -g display-time 3000
set -g escape-time 0
set -g history-limit 65535
set -g base-index 1
set -g pane-base-index 1

# 前缀绑定 (Ctrl+a)
set -g prefix ^a
unbind ^b
bind a send-prefix

# 分割窗口
unbind '"'
bind - splitw -v
unbind %
bind | splitw -h

# 选中窗口
bind-key k select-pane -U
bind-key j select-pane -D
bind-key h select-pane -L
bind-key l select-pane -R

# copy-mode 将快捷键设置为 vi 模式
setw -g mode-keys vi

# 启用鼠标(Tmux v2.1)
set -g mouse on

# 更新配置文件
bind r source-file ~/.tmux.conf \; display "已更新"

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# Tmux Plugin Manager(Tmux v2.1)
# Tmux Resurrect
set -g @plugin 'tmux-plugins/tmux-resurrect'

# List of plugins
set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-sensible'

# Other examples:
# set -g @plugin 'github_username/plugin_name'
# set -g @plugin 'git@github.com/user/plugin'
# set -g @plugin 'git@bitbucket.com/user/plugin'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run '~/.tmux/plugins/tpm/tpm'
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
```

### FreeBSD系统完全备份
<font size="2" color="gray">2019-11-05</font>


```
摘要：

FreeBSD操作系统是非常稳定的，但是这并不是说FreeBSD系统都不备份数据，系统备份是系统管理中一个重要的部分。

在学习使用FreeBSD的过程中经常需要对系统进行某些实验性的操作，这时就有可能把系统搞乱，

只要你是正常操作搞坏一个FreeBSD还是比较困难的，如果没有root权限的话，几乎就是不可能的，当然你可以把自己的home塞满，如果管理员没有使用quato技术的话。 但是想搞坏一个FreeBSD也是很容易的，比如说你在行使root权限时随便输入了一个错误的命令。

这个Wiki页面将会介绍一种FreeBSD系统的完全备份方法，主要基于FreeBSD Forum上killasmurf86一个关于Backup的帖子。

在FreeBSD的Handbook上专门内容讲系统备份，在网上也有很多关于FreeBSD系统的备份文章，这个wiki页面的主要目的在于给出一个详细的备份以及恢复系统的过程描述。

基本的游戏规则：

FreeBSD系统的备份不需要什么特殊的工具，你需要的工具在FreeBSD的基本系统里面就有；
FreeBSD系统的备份就是对系统文件的打包，然后放到一个安全的地方，本文中使用的打包工具是dump；
FreeBSD系统的恢复就是把你保存好的系统文件从安全的地方里面拿出来放到你的硬盘上去，本文中使用的恢复工具是restore；
Unix-like下面不使用ghost之类的备份工具。
需要使用的工具：

FreeBSD基本系统中有很多工具可以备份，比如说tar。

但是在这个Wiki页面中我们只使用：dump+restore+freebsd_livefs_cd。

其中freebsd_livefs_cd可以到任意的FreeBSD的ftp服务器去下载。

示例系统分区简介：

这个台式机只有1块硬盘，并且只有一个FreeBSD操作系统，其分区方案如下。

df -h
Filesystem      Size    Used   Avail Capacity  Mounted on
/dev/ad12s1a    496M     36M    420M     8%    /
devfs           1.0K    1.0K      0B   100%    /dev
/dev/ad12s1h    240G    1.5G    219G     1%    /home
/dev/ad12s1e    3.9G    166K    3.6G     0%    /tmp
/dev/ad12s1f     19G    3.1G     15G    17%    /usr
/dev/ad12s1g     19G    1.3G     17G     7%    /usr/local
/dev/ad12s1d    3.9G     55M    3.5G     2%    /var
procfs          4.0K    4.0K      0B   100%    /proc
cat /etc/fstab
# Device		Mountpoint	FStype	Options  Dump  Pass
/dev/ad12s1b		none		swap	sw		0	0
/dev/ad12s1a		/		ufs	rw		1	1
/dev/ad12s1h		/home		ufs	rw		2	2
/dev/ad12s1e		/tmp		ufs	rw		2	2
/dev/ad12s1f		/usr		ufs	rw		2	2
/dev/ad12s1g		/usr/local	ufs	rw		2	2
/dev/ad12s1d		/var		ufs	rw		2	2
/dev/acd0		/cdrom		cd9660	ro,noauto	0	0
proc			/proc		procfs  rw		0	0
从这个分区来看，是一个320G的硬盘，上面只有一个FreeBSD操作系统，每个分区的大致用途如下，详情可以参考hier(7)。

/ 这个目录存放很多基本工具，包括内核，需要备份；

/dev 这是一个虚拟的文件系统，不需要备份；

/home 用户数据，需要备份；但是有些情况下，/home目录是/usr/home目录的一个符号链接，这时候可以不备份，而只需要备份/usr；

/tmp 临时文件，不需要备份；

/usr 很多工具以及系统的源代码都放在这里面，需要备份；

/usr/local 所有安装的软件基本上都在这里，需要备份；

/var 系统的日志，ports系统的数据库，需要备份；

/proc 虚拟文件系统，不需要必要备份。

看来需要备份以下目录：

/

/home

/usr

/usr/local

/var

备份的方法：

以/分区为例，我通常直接备份到我的移动硬盘上面。

我的移动硬盘使用的是UFS文件系统，分了4个partition，一般情况下我会把移动硬盘关在在我的/mnt/fender_01目录下面，假设目前系统一切正常，我现在打算做一个备份，那么我就应该关在移动硬盘某个分区到/mnt/fender_01目录下，然后分别对所有需要备份的分区进行备份，这里只给出“/”分区备份的例子。

“/”分区对应我硬盘上面的/dev/ad12s1a，那么备份整个分区的命令如下：

dump -0Lauf /mnt/fender_01/dump/ad12sa1.dump /dev/ad12s1a
某些时候，起一个好的文件名很重要！ ^_^

其中：

-0 备份所有的文件系统中的内容，也就是不使用增量备份；

-f 指定备份结果存放的文件名；

-a 告诉dump不考虑备份的介质的大小问题，早期备份使用磁带，dump会预先计算一下需要的空间，使用这个选项告诉dump忽略这个问题；

-u 告诉dump更新一下/etc/dumpdates，这个文件记录了你在系统上所有的备份活动；

-L 备份已经挂载的文件系统时需要，这个选项会使用UFS2的snapshot功能来保证文件系统的一致性。

恢复系统的方法：

恢复“/”以外的文件系统：

如果你只想恢复/以外的文件系统，那么很容易，

我们以恢复/home文件系统为例，你只需要重启系统进入单用户模式，

挂载/tmp分区，应为restore需要使用/tmp分区，

挂载移动硬盘上保存我备份文件的分区到/mnt目录下面的某个，例如/mnt/01，

按照我上面命名的规则，备份生成的文件应该是保存在/mnt/01/dump/dev/ad12s1h.dump，

首先你需要格式化/dev/ad12s1h，命令如下：

newfs -U /dev/ad12s1h
-U选型来打开softupdate。

挂在这个分区到/mnt下面的某个目录，例如/mnt/02/

mount /dev/ad12s1h /mnt/02
现在来恢复文件系统：

cd /mnt/02

restore -rf /mnt/01/dump/ad12s1h.dump
恢复“/”:

按照上面的方法你可以恢复/以外的任意的分区，但是你不能恢复“/”，因为你如果使用newfs格式化了“/”你就没有办法使用“/”里面的restore了，

解决的办法就是使用freebsd_livefs_cd启动系统，然后选择fix，之后选择cd，之后的过程就和上面介绍的恢复其他分区是一样的了。

事实上，可以使用freebsd_livefs_cd来恢复任何分区，但是如果你没有下载并刻录这张光盘，那么你就只能在单用户模式下面恢复“/”以外的分区了。

需要注意的是，当你格式化“/”对应的硬盘分区时，可以使用下述两种方法：

newfs /dev/ad12s1a
newfs -U /dev/ad12s1a
区别在于后者将打开softupdate选项，详细情况参考newfs。

在FreeBSD系统的安装过程中“/”分区默认是不打开softupdate的，并且你也没有办法打开，因为sysinstall程序不允许你打开。

这是一个历史遗留问题，当时softupdate还不成熟，于是决定在“/”分区中禁止使用softupdate，现在softupdate已经成熟了，但是对这个问题却保留了下来。 ^_^

在“/”分区使用softupdate不会造成什么问题，但是在系统安装的默认设置中是没有打开的，这一点需要注意。

可以使用如果想打开或者关闭softupdate这个选项，可以使用tunefs(8)这个工具。

备份MBR：

上面只提到了备份文件系统，没有讲如何备份系统的MBR。

关于MBR是什么就不详细介绍了，有兴趣的可以参考Handbook上面有一章专门介绍FreeBSD系统的启动过程。

备份：

dd if=/dev/da0 of=/path/to/mbr.img bs=512 count=1
恢复：

dd if=/path/to/mbr.img of=/dev/da0 bs=512 count=1
参考：

dump(8)

restore(8)

tunefs(8)

newfs

hier(7)

注意：

系统的备份与恢复并不十分困难，但是如果你不慎输入某个错误的命令的话，有可能导致某些灾难性的后果。

重做系统需要的是时间，但是如果重要数据丢失了，那就不只是时间的问题了。

所以，在备份与恢复系统时，请尽量保证自己头脑清醒。
```

### tty配置/安装删除软件/升级系统
<font size="2" color="gray">2019-11-05</font>


```
1.修改tty分辨率（改变控制台的显示模式）
关键

/boot/loader.conf
kern.vty=sc
/etc/rc.conf
allscreens_flags="MODE_280"

选择分辨率
vidcontrol -i mode
vidcontrol MODE_300
******************************************************
2.同步时间
ntpdate cn.pool.ntp.org
1.首先在rc.conf里面添加：ntpd_enable=”YES”。
2.修改/etc/ntp.conf
server 0.freebsd.pool.ntp.org iburst maxpoll 9
server 1.freebsd.pool.ntp.org iburst maxpoll 9
server 2.freebsd.pool.ntp.org iburst maxpoll 9
其他全部注释掉。
3.启动ntpd之前需要手动运行ntpdate time.windows.com先同步一下时间，避免因为系统时间与时间服务期时间相差太大导致渐次逼近无法实施而造成的ntpd运行失败。
4.运行/etc/rc.d/ntpd start启动服务。
5.可以通过ntpq -p命令来检查当前ntpd服务状态，注意看输出的表格中st这一项值，必须小于16，16代表无法连接时间服务器，如果都为16，则对时不能完成，需要检查网络原因。
6.ntpd服务需要开放对udp端口123的访问。）
****************************************************
3.修改loader.conf 不重启加载

kldload 
*******************************************************
4.升级系统

freebsd-update -r 11.2 upgrade
*******************************************************
5.查看其他终端
watch -W ttyp1（能写入）
watch ttyp1

切换终端： Ctrl+x
退出watch：Ctrl+g

*********************************************************
6.查看网关
arp -a （查看ip 和 物理地址映射）

查看某个端口是否打开

telnet ip port

ssh连接

ssh 110.249.219.173 -l helo -p 8192

执行csh脚本

csh  ?.csh(!#/usr/bin/csh)

测试vuz端口是否打开
nc -vuz 110.249.219.173 6881
.我们使用nc来进行测试，如下
[root@kr-sg-test ~]# nc -vuz 42.11.12.13 123
Connection to 42.11.12.13 123 port [udp/ntp] succeeded!
结果证明UDP 123端口正常监听。
nc命令用法：
usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]
[-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]
[-x proxy_address[:port]] [hostname] [port[s]]



1．命令格式;

tail[必要参数][选择参数][文件]   

2．命令功能：

用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。

3．命令参数：

-f 循环读取

-q 不显示处理信息

-v 显示详细的处理信息

-c<数目> 显示的字节数

-n<行数> 显示行数

–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. 

-q, –quiet, –silent 从不输出给出文件名的首部 

-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 



解压gz文件 无tar



pkg info -d ??? 查看依赖信息 


# pkg query "Package name = %n, Version = %v, Size = %sh" libxml2
Package name = libxml2, Version = 2.7.8_5, Size = 4 MB

# pkg query -a "Package name = %n, Version = %v, Size = %sh"


sysctl net.inet.ip.forwarding=1

gateway_enable=yes


两种方法，一种是  rc.conf 中添加 gateway_enable=YES
一种是 /etc/sysctl.conf 中添加  net.inet.ip.forwarding=1

冰河四世纪 2018/10/26 17:22:49
不重启系统要修个这个变量的话就手工执行
sysctl net.inet.ip.forwarding=1


*****************************************************************
删除没有被依赖的包


# pkg audit -F
# pkg check -s -a
# pkg check -d -a


pkg autoremove
```
### 开启ssh登陆
<font size="2" color="gray">2019-11-05</font>


```
1、安装时选择上SSH，或者源码安装SSH
2、使用root登陆系统
3、使用ee编辑器编辑/etc/inetd.conf，去掉ssh前的#，按ctrl+c，再输入exit保存退出
4、编辑/etc/rc.conf，添加一行sshd_enable="YES"
5、编辑/etc/ssh/sshd_config，将
#PermitRootLogin no改为PermitRootLogin yes //允许root登陆
#PasswordAuthentication no改为PasswordAuthenticationyes//使用系统PAM认证
#PermitEmptyPasswords no改为PermitEmptyPasswords no//不允许空密码

修改端口号：/etc/ssh/sshd_config

    #port=22改为 Port=number（你想修改的数字）

保存退出
6、启动SSHD服务，/etc/rc.d/sshd start
7、查看服务是否启动，netstat -an，如果看到22端口有监听，恭喜！！！
```


### scp命令详解
<font size="2" color="gray">2019-11-05</font>


```
先说下常用的情况：

两台机器IP分别为：A.104.238.161.75，B.43.224.34.73。

在A服务器上操作，将B服务器上/home/lk/目录下所有的文件全部复制到本地的/root目录下，命令为：scp -r root@43.224.34.73:/home/lk /root。

具体过程为：

复制代码
[root@XX ~]# scp -r root@43.224.34.73:/home/lk /root
root@43.224.34.73's password: 
k2.sql                                                     100%    0     0.0KB/s   00:00    
k.zip                                                      100%  176     0.2KB/s   00:00    
.bash_history                                              100%   32     0.0KB/s   00:00    
.bash_logout                                               100%   18     0.0KB/s   00:00    
.bashrc                                                    100%  231     0.2KB/s   00:00    
k3.sql                                                     100%    0     0.0KB/s   00:00    
.bash_profile                                              100%  193     0.2KB/s   00:00    
[root@XX ~]# ls
复制代码
在A服务器上将/root/lk目录下所有的文件传输到B的/home/lk/cpfile目录下，命令为：scp -r /root/lk root@43.224.34.73:/home/lk/cpfile。

具体过称为：

复制代码
[root@XX lk]# scp -r /root/lk root@43.224.34.73:/home/lk/cpfile
root@43.224.34.73's password: 
k2.sql                                                     100%    0     0.0KB/s   00:00    
k3.sql                                                     100%    0     0.0KB/s   00:00    
.bash_profile                                              100%  193     0.2KB/s   00:00    
.bash_logout                                               100%   18     0.0KB/s   00:00    
.bash_history                                              100%   32     0.0KB/s   00:00    
k.zip                                                      100%  176     0.2KB/s   00:00    
.bashrc                                                    100%  231     0.2KB/s   00:00    
[root@XX lk]# 
复制代码
scp在夸机器复制的时候为了提高数据的安全性，使用了ssh连接和加密方式，如果机器之间配置了ssh免密码登录，那在使用scp的时候密码都不用输入。

命令详解：

scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。

1．命令格式：

scp [参数] [原路径] [目标路径]

2．命令功能：

scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。

3．命令参数：

-1  强制scp命令使用协议ssh1  

-2  强制scp命令使用协议ssh2  

-4  强制scp命令只使用IPv4寻址  

-6  强制scp命令只使用IPv6寻址  

-B  使用批处理模式（传输过程中不询问传输口令或短语）  

-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  

-p 保留原文件的修改时间，访问时间和访问权限。  

-q  不显示传输进度条。  

-r  递归复制整个目录。  

-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   

-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   

-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  

-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    

-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     

-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   

-P port  注意是大写的P, port是指定数据传输用到的端口号   

-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。

4．使用实例：

scp命令的实际应用概述：  

从本地服务器复制到远程服务器： 

(1) 复制文件：  

命令格式：  

scp local_file remote_username@remote_ip:remote_folder  

或者  

scp local_file remote_username@remote_ip:remote_file  

或者  

scp local_file remote_ip:remote_folder  

或者  

scp local_file remote_ip:remote_file  

第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名  

第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名   

(2) 复制目录：  

命令格式：  

scp -r local_folder remote_username@remote_ip:remote_folder  

或者  

scp -r local_folder remote_ip:remote_folder  

第1个指定了用户名，命令执行后需要输入用户密码；  

第2个没有指定用户名，命令执行后需要输入用户名和密码；
```


### 删除所有小于100K的文件
<font size="2" color="gray">2019-11-05</font>


```
find . -type f -size -100k -print | grep -v "jpg\|JPG" | xargs -0 -n1 rm -rf

find  -print 打印 prit0 不打印
size  +100 -100 100占空间大小 0c 100c文件大小
find  -type d文件夹 -empty空文件夹 f文件
grep  -v 排除指定字符
xargs -0 处理特定字符
```
```
find . -name "shuaige.txt" -exec rm -f {} ;  

”；“可以没有

find ./ -name "*.torrent" -exec rm -rf {} \;
-exec 必须有- 后面命令参数占位{} 和 \; 都得有

```

### Fdupes查找删除重复文件并删除空目录
<font size="2" color="gray">2019-11-05</font>

```
Fdupes 用法非常简单。仅运行下面的命令就可以在目录中找到重复文件，如：~/Downloads。  
$ fdupes ~/Downloads
我系统中的样例输出：
/home/sk/Downloads/Hyperledger.pdf 
/home/sk/Downloads/Hyperledger(1).pdf  
你可以看到，在 /home/sk/Downloads/ 目录下有一个重复文件。它仅显示了父级目录中的重复文件。如何显示子目录中的重复文件？像下面一样，使用 -r 选项。
$ fdupes -r ~/Downloads
现在你将看到 /home/sk/Downloads/ 目录以及子目录中的重复文件。

Fdupes 也可用来从多个目录中迅速查找重复文件。
$ fdupes ~/Downloads ~/Documents/ostechnix
你甚至可以搜索多个目录，递归搜索其中一个目录，如下：

$ fdupes ~/Downloads -r ~/Documents/ostechnix
上面的命令将搜索 ~/Downloads 目录，~/Documents/ostechnix 目录和它的子目录中的重复文件。

有时，你可能想要知道一个目录中重复文件的大小。你可以使用 -S 选项，如下：

$ fdupes -S ~/Downloads
403635 bytes each:
/home/sk/Downloads/Hyperledger.pdf
/home/sk/Downloads/Hyperledger(1).pdf
类似的，为了显示父目录和子目录中重复文件的大小，使用 -Sr 选项。

我们可以在计算时分别使用 -n 和 -A 选项排除空白文件以及排除隐藏文件。

$ fdupes -n ~/Downloads
$ fdupes -A ~/Downloads
在搜索指定目录的重复文件时，第一个命令将排除零长度文件，后面的命令将排除隐藏文件。

汇总重复文件信息，使用 -m 选项。

$ fdupes -m ~/Downloads
1 duplicate files (in 1 sets), occupying 403.6 kilobytes
删除所有重复文件，使用 -d 选项。

$ fdupes -d ~/Downloads
样例输出：

[1] /home/sk/Downloads/Hyperledger Fabric Installation.pdf
[2] /home/sk/Downloads/Hyperledger Fabric Installation(1).pdf

Set 1 of 1, preserve files [1 - 2, all]:
这个命令将提示你保留还是删除所有其他重复文件。输入任一号码保留相应的文件，并删除剩下的文件。当使用这个选项的时候需要更加注意。如果不小心，你可能会删除原文件。

如果你想要每次保留每个重复文件集合的第一个文件，且无提示的删除其他文件，使用 -dN 选项（不推荐）。

$ fdupes -dN ~/Downloads
当遇到重复文件时删除它们，使用 -I 标志。

$ fdupes -I ~/Downloads
关于 Fdupes 的更多细节，查看帮助部分和 man 页面。

$ fdupes --help
$ man fdupes
```
[原文地址](https://linux.cn/article-10123-1.html?pr)


### 文件内容查找和替换命令
<font size="2" color="gray">2019-11-04</font>  
几种常见的文件内容查找和替换命令
#### 1. 通过vim编辑器来替换

```
vi/vim 中可以使用 :s 命令来替换字符串。

:s/well/good/ 替换当前行第一个 well 为 good

:s/well/good/g 替换当前行所有 well 为 good

:n,$s/well/good/ 替换第 n 行开始到最后一行中每一行的第一个 well 为 good

:n,$s/well/good/g 替换第 n 行开始到最后一行中每一行所有 well 为 good n 为数字，若 n 为 .，表示从当前行开始到最后一行

:%s/well/good/（等同于 :g/well/s//good/） 替换每一行的第一个 well 为 good

:%s/well/good/g（等同于 :g/well/s//good/g） 替换每一行中所有 well 为 good 可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符

:s#well/#good/# 替换当前行第一个 well/ 为 good/

```
#### 2. sed和grep配合
```
sed -i s/yyyy/xxxx/g `grep yyyy -rl --include="*.txt" ./`

作用：将当前目录(包括子目录)中所有txt文件中的yyyy字符串替换为xxxx字符串。其中，

-i 表示操作的是文件，``括起来的grep命令，表示将grep命令的的结果作为操作文件。

s/yyyy/xxxx/表示查找yyyy并替换为xxxx，后面跟g表示一行中有多个yyyy的时候，都替换，而不是仅替换第一个

另外，如果不需要查找子目录，仅需要在当前目录替换，用sed命令就行了，命令如下：sed -i s/xxxx/yyyy/g ./*.txt

```
#### 3. find命令查找和替换 
```
find -name '要查找的文件名' | xargs perl -pi -e 's|被替换的字符串|替换后的字符串|g'          #查找替换当前目录下包含字符串并进行替换

find -name '*.txt' | xargs perl -pi -e 's|被替换内容|替换内容|g'             #递归查找替换

find . -type f -name '*.html' | xargs perl -pi -e 's|被替换内容|替换内容|g'

```
我用到的：  

```
find . -type f -name '*.html' | xargs perl -pi -e 's/utf-8/iso-8859-1/g'  
```
[原文链接](https://blog.csdn.net/qq_25992179/article/details/82777486)


### wget整站克隆仿站
<font size="2" color="gray">2019-11-03</font>  
通过如下命令可以整个网站的源码下载到本地
```
$ wget -r -p -np -k www.avatrade.cn
```
Wget参数说明:   
```
-r --recursive（递归） specify recursive download.（指定递归下载）
-k --convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接）
-p --page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容）
-np --no-parent（不追溯至父级） don't ascend to the parent directory.

这里写代码片额外参数：

-nc  断点续传
-o   生成日志文件
```  
[原文链接](https://blog.csdn.net/qq_28590879/article/details/79849307)

### ffmpeg转码
<font size="2" color="gray">2019-11-03</font>  
```
ffmpeg -i in.rm -c:v h264 -c:a aac "out.mp4"
```